<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2020/03/19/java-interview/"/>
      <url>/2020/03/19/java-interview/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面试基础知识"><a href="#Java-面试基础知识" class="headerlink" title="Java 面试基础知识"></a>Java 面试基础知识</h1><h2 id="Java设计思想"><a href="#Java设计思想" class="headerlink" title="Java设计思想"></a>Java设计思想</h2><h3 id="0-OOP是什么"><a href="#0-OOP是什么" class="headerlink" title="0. OOP是什么"></a>0. OOP是什么</h3><blockquote><p>面向对象编程（Object Oriented Programming）</p></blockquote><h3 id="1-面向对象的特征有哪些"><a href="#1-面向对象的特征有哪些" class="headerlink" title="1.面向对象的特征有哪些"></a>1.面向对象的特征有哪些</h3><p>面向对象的特征有：<strong>抽象</strong>、<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong></p><blockquote><ol><li>抽象：抽象是将<strong>一类对象的共同特征</strong>总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</li><li>封装：隐藏对象的实现细节，仅对外公开接口，是针对一个对象来说的</li><li>多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情</li><li>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）</li></ol></blockquote><h3 id="2-java是值传递还是引用传递"><a href="#2-java是值传递还是引用传递" class="headerlink" title="2. java是值传递还是引用传递"></a>2. java是值传递还是引用传递</h3><blockquote><p>java是值传递。可以理解为传入的是一个引用的副本，指向统一地址。当值改变时，原引用和副本指向地址中的值都变了；当副本指向的地址改变，指向新值时，原引用指向的地址没有改变，原值也没有改变。</p></blockquote><p>基础类型如int long等，引用类型例如String</p><pre class=" language-Java"><code class="language-Java">第一个例子：基本类型void foo(int value) {    value = 100;}foo(num); // num 没有被改变第二个例子：没有提供改变自身方法的引用类型void foo(String text) {    text = "windows";}foo(str); // str 也没有被改变第三个例子：提供了改变自身方法的引用类型StringBuilder sb = new StringBuilder("iphone");void foo(StringBuilder builder) {    builder.append("4");}foo(sb); // sb 被改变了，变成了"iphone4"。第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。StringBuilder sb = new StringBuilder("iphone");void foo(StringBuilder builder) {    builder = new StringBuilder("ipad");}foo(sb); // sb 没有被改变，还是 "iphone"。</code></pre><p>Java 堆(Heap) 和 栈(Stack) 。</p><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p><strong>从局部变量/方法参数开始讲起：</strong></p><p>局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。</p><p>我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更遑论修改。</p><p>当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。</p><p><strong>数组类型引用和对象：</strong></p><p>当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。</p><p>当我们声明一个二维数组时，如 int[][] arr2 = new int[2][4]，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。</p><p><img src="v2-6590cb935ae8bf3b7241cb309fe041d7_hd.jpg" alt="v2-6590cb935ae8bf3b7241cb309fe041d7_hd"></p><p>所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。</p><p>你还可以这样声明：int[][] arr3 = new int[3][]，这时内存情况如下图</p><p><img src="v2-fdc86227021d56a02b559d6485983c71_hd.jpg" alt="img"></p><p>你还可以这样 arr3[0] = new int [5]; arr3[1] = arr2[0];</p><p><img src="v2-fdc5e737a95d625a47d66ab61e4a2f55_hd.jpg" alt="img"></p><p><strong>关于String：</strong></p><p>原本回答中关于String的图解是简化过的，实际上String对象内部仅需要维护三个变量，char[] chars, int startIndex, int length。而chars在某些情况下是可以共用的。但是因为String被设计成为了不可变类型，所以你思考时把String对象简化考虑也是可以的。</p><p>String str = new String(“hello”)</p><p><img src="v2-a143d0a3594d06f54c6853c46c429e08_hd.jpg" alt="img"></p><p>当然某些JVM实现会把”hello”字面量生成的String对象放到常量池中，而常量池中的对象可以实际分配在heap中，有些实现也许会分配在方法区，当然这对我们理解影响不大。</p><h3 id="3-设计模式之面向对象七大基本原则"><a href="#3-设计模式之面向对象七大基本原则" class="headerlink" title="3. 设计模式之面向对象七大基本原则"></a>3. 设计模式之面向对象七大基本原则</h3><h4 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h4><p>每一个类应该专注于做一件事情。</p><h4 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h4><p>超类存在的地方，子类是可以替换的。</p><h4 id="依赖倒置原则（Dependence-Inversion-Principle）"><a href="#依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h4><p>实现尽量依赖抽象，不依赖具体实现。</p><h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h4><p>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</p><h4 id="迪米特法则（Law-Of-Demeter）"><a href="#迪米特法则（Law-Of-Demeter）" class="headerlink" title="迪米特法则（Law Of Demeter）"></a>迪米特法则（Law Of Demeter）</h4><p>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</p><h4 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h4><p>面向扩展开放，面向修改关闭。</p><h4 id="组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）"><a href="#组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）" class="headerlink" title="组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）"></a>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</h4><p>尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</p><h4 id="细则"><a href="#细则" class="headerlink" title="细则"></a>细则</h4><h5 id="单一职责原则（Single-Responsibility-Principle）-1"><a href="#单一职责原则（Single-Responsibility-Principle）-1" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h5><p>因为：</p><p>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p><p>所以：</p><p>从大局上看Android中的Paint和Canvas等类都遵守单一职责原则，Paint和Canvas各司其职。</p><h5 id="里氏替换原则（Liskov-Substitution-Principle）-1"><a href="#里氏替换原则（Liskov-Substitution-Principle）-1" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h5><p>因为：</p><p>里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p>所以：</p><p>使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</p><p>从大局看Java的多态就属于这个原则。</p><h5 id="依赖倒置原则（Dependence-Inversion-Principle）-1"><a href="#依赖倒置原则（Dependence-Inversion-Principle）-1" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）"></a>依赖倒置原则（Dependence Inversion Principle）</h5><p>因为：</p><p>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。</p><p>所以：</p><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。</p><p>从大局看Java的多态就属于这个原则。</p><h5 id="接口隔离原则（Interface-Segregation-Principle）-1"><a href="#接口隔离原则（Interface-Segregation-Principle）-1" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h5><p>因为：</p><p>提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。譬如类ProgramMonkey通过接口CodeInterface依赖类CodeC，类ProgramMaster通过接口CodeInterface依赖类CodeAndroid，如果接口CodeInterface对于类ProgramMonkey和类CodeC来说不是最小接口，则类CodeC和类CodeAndroid必须去实现他们不需要的方法。将臃肿的接口CodeInterface拆分为独立的几个接口，类ProgramMonkey和类ProgramMaster分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p><p>所以：</p><p>建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障。</p><h5 id="迪米特法则（Law-Of-Demeter）-1"><a href="#迪米特法则（Law-Of-Demeter）-1" class="headerlink" title="迪米特法则（Law Of Demeter）"></a>迪米特法则（Law Of Demeter）</h5><p>因为：</p><p>类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式；对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。</p><p>所以：</p><p>一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用，在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用。</p><p>从大局来说Android App开发中的多Fragment与依赖的Activity间交互通信遵守了这一法则。</p><h5 id="开闭原则（Open-Close-Principle）-1"><a href="#开闭原则（Open-Close-Principle）-1" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h5><p>因为：</p><p>开放封闭原则主要体现在对扩展开放、对修改封闭，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。</p><p>所以：</p><p>可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭，对扩展开放的设计思路。<br>封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。</p><h5 id="组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）-1"><a href="#组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-CARP）-1" class="headerlink" title="组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）"></a>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</h5><p>因为：</p><p>其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。</p><p>如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</p><p>所以：</p><p>组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="0-接口的意义"><a href="#0-接口的意义" class="headerlink" title="0. 接口的意义"></a>0. 接口的意义</h3><blockquote><ol><li>规范</li><li>扩展</li><li>回掉</li><li>java是单继承的</li></ol></blockquote><h3 id="1-抽象类的意义"><a href="#1-抽象类的意义" class="headerlink" title="1. 抽象类的意义"></a>1. 抽象类的意义</h3><blockquote><ol><li>为其他子类提供一个公共的类型</li><li>封装子类中重复定义的内容</li><li>定义抽象方法,子类可以有不同的实现</li></ol></blockquote><h3 id="2-抽象类和接口有什么不同"><a href="#2-抽象类和接口有什么不同" class="headerlink" title="2. 抽象类和接口有什么不同"></a>2. 抽象类和接口有什么不同</h3><blockquote><ol><li>单继承：java中只可以继承一个类，但是可以实现多个接口</li><li>成员变量：接口的成员变量都是public static final 的，抽象类可以有各种类型</li><li>方法：抽象类中可以有方法的具体实现，接口中方法都是抽象的</li><li>扩展：//jdk 7 : 只能声明全局常量(public static final)和抽象方法(public abstract) void method1(); // jdk 8 : 声明静态方法 和 默认方法 public static void method2(){ System.out.println(“method2”); } default void method3(){ System.out.println(“method3”); method4(); } //jdk 9 : 声明私有方法 private void method4(){ System.out.println(“私有方法”); }}</li></ol></blockquote><h3 id="3-接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？"><a href="#3-接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？" class="headerlink" title="3. 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？"></a>3. 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</h3><blockquote><ol><li>接口可以继承接口,而且支持多重继承</li><li>抽象类可以实现(implements)接口</li><li>抽象类是可继承具体类,也可以继承抽象类</li></ol></blockquote><h3 id="4-Java标识符命名规范"><a href="#4-Java标识符命名规范" class="headerlink" title="4. Java标识符命名规范"></a>4. Java标识符命名规范</h3><h4 id="0-规范（强制）"><a href="#0-规范（强制）" class="headerlink" title="0. 规范（强制）"></a>0. 规范（强制）</h4><blockquote><ol><li>数字、字母、下划线、$（java中内部类编译后会生成包含$的类名） 组成</li><li>不能以数字开头</li><li>不能和关键字或保留关键字相同</li></ol></blockquote><h4 id="1-推荐的命名方式（非强制）"><a href="#1-推荐的命名方式（非强制）" class="headerlink" title="1. 推荐的命名方式（非强制）"></a>1. 推荐的命名方式（非强制）</h4><blockquote><ol><li>方法:java中通常用小驼峰命名法</li><li>常量：通常用大写字母，不同单词间用“_”分隔开，如MOBILE_NUM</li><li>类名：大驼峰命名法</li></ol></blockquote><h2 id="类和方法"><a href="#类和方法" class="headerlink" title="类和方法"></a>类和方法</h2><h3 id="0-一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#0-一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="0. 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>0. 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h3><blockquote><p>一个”.java”文件内可以有多个类，但只能有一个类是公开的</p></blockquote><h3 id="1-构造器（constructor）是否可被重写（override）"><a href="#1-构造器（constructor）是否可被重写（override）" class="headerlink" title="1. 构造器（constructor）是否可被重写（override）"></a>1. 构造器（constructor）是否可被重写（override）</h3><blockquote><p>构造器不能被继承，因此不能被重写，但可以被重载</p></blockquote><h3 id="2-静态变量和成员变量的区别"><a href="#2-静态变量和成员变量的区别" class="headerlink" title="2. 静态变量和成员变量的区别"></a>2. 静态变量和成员变量的区别</h3><blockquote><ol><li>静态变量属于类，被多个实例共享，成员变量属于实例</li><li>静态变量储存在方法区，成员变量在堆</li><li>静态变量在类加载时候存在，成员变量在实例加载之后存在</li><li>静态方法可以直接使用静态变量，不能直接使用成员变量</li></ol></blockquote><h3 id="3-Object-中定义了哪些方法"><a href="#3-Object-中定义了哪些方法" class="headerlink" title="3. Object 中定义了哪些方法"></a>3. Object 中定义了哪些方法</h3><blockquote><p>clone/toString/wait/notify/notifyAll/equals/hashcode/finalize/getClass</p></blockquote><h3 id="4-Cloneable-实现原理"><a href="#4-Cloneable-实现原理" class="headerlink" title="4. Cloneable 实现原理"></a>4. Cloneable 实现原理</h3><blockquote><ol><li>Cloneable是一个接口，没有具体方法</li><li>clone方法是Object类中方法，会检查当前实例是否实现Cloneable接口，没有实现则抛出异常，实现了就调用native方法进行clone（clone进行的是浅拷贝），源码如下</li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Cloneable</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">(</span><span class="token string">"Class "</span> <span class="token operator">+</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                                                 <span class="token string">" doesn't implement Cloneable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">internalClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="5-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#5-两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="5. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>5. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h3><blockquote><ol><li>不对。</li><li>java 规定，值相同，hashCode一定要相同；hashCode相同，值可能不同</li><li>如果值相同，hashCode不同，就会造成Hashset、HashMap等借助hashCode实现的数据结构出现错乱，相同的值或者key可能出现多次</li></ol></blockquote><h3 id="6-如何实现对象的克隆"><a href="#6-如何实现对象的克隆" class="headerlink" title="6. 如何实现对象的克隆"></a>6. 如何实现对象的克隆</h3><blockquote><ol><li>通过实现Cloneable接口实现clone：这里要注意深拷贝和浅拷贝问题，如果该类内部变量是引用类型的，并且内部变量类没有实现Cloneable接口，那么克隆出来的该变量是浅拷贝的（只是复制了引用，两个引用指向统一实例）</li><li>通过实现Serializable接口，通过对象的序列化和反序列化实现克隆。</li></ol></blockquote><pre><code>import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class MyUtil {private MyUtil() {throw new AssertionError();}@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T extends Serializable&gt; T clone(T obj) throws Exception {ByteArrayOutputStream bout = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(bout);oos.writeObject(obj);ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());ObjectInputStream ois = new ObjectInputStream(bin);return (T) ois.readObject();// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放}}</code></pre><h3 id="7-谈一谈”-“与”equals-”的区别"><a href="#7-谈一谈”-“与”equals-”的区别" class="headerlink" title="7. 谈一谈”==“与”equals()”的区别"></a>7. 谈一谈”==“与”equals()”的区别</h3><blockquote><ol><li>== :对于基本类型，比较的是他们的值；对于引用类型，比较的是引用的值，也就是对象实例的地址</li><li>equals()方法是Object类中的方法，默认实现是public boolean equals(Object obj) {return (this == obj);}；我们可以重写该方法达到我们的目的，例如String重写了该方法要求每个字符都相等。</li></ol></blockquote><h3 id="8-类中方法调用顺序"><a href="#8-类中方法调用顺序" class="headerlink" title="8. 类中方法调用顺序"></a>8. 类中方法调用顺序</h3><p>指出下面程序的运行结果</p><pre><code>class A {static {System.out.print(&quot;1&quot;);}public A() {System.out.print(&quot;2&quot;);}}class B extends A{static {System.out.print(&quot;a&quot;);}public B() {System.out.print(&quot;b&quot;);}}public class Hello {public static void main(String[] args) {A ab = new B();ab = new B();}}复制代码</code></pre><blockquote><p>执行结果：1a2b2b。 创建对象时构造器的调用顺序是：  父类静态初始化块  -&gt; 子类静态初始化块 -&gt; 父类初始化块 -&gt;调用了父类构造器 -&gt; 子类初始化块 -&gt; 调用子类的构造器</p></blockquote><h3 id="9-重载（Overload）和重写（Override）的区别"><a href="#9-重载（Overload）和重写（Override）的区别" class="headerlink" title="9. 重载（Overload）和重写（Override）的区别"></a>9. 重载（Overload）和重写（Override）的区别</h3><blockquote><p>重写（Override）和重载（Overload）其实并无联系，可能是因为名称相似，容易引起混淆 &gt; <a href="https://www.runoob.com/java/java-override-overload.html" target="_blank" rel="noopener">重写发生在运行时，重载发生在编译期</a></p></blockquote><h4 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h4><p>重写是针对父类和子类来说的，是在子类中重写父类的方法。</p><blockquote><ol><li>要求方法名，参数个数和类型必须相同</li><li>返回的数据类型必须与父类相同或者是其子类</li><li>访问修饰符的限制一定要大于父类中该方法的访问修饰符（public&gt;protected&gt;default&gt;private）</li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li></ol></blockquote><h4 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h4><p>重载是针对一个类说的，是Java中多态性的一种表现</p><blockquote><ol><li>要求方法名相同</li><li>必须有不同的参数列表</li><li>可以有不同的返回类型</li><li>可以有不同的修饰符</li><li>可以抛出不同的异常。</li></ol></blockquote><pre><code>扩展：华为的面试题中曾经问过这样一个问题 - &quot;为什么不能根据返回类型来区分重载&quot;答：因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。例如：float max(int a, int b);int max(int a, int b);当调用max(1, 2);时无法确定调用的是哪个。参考：https://www.zhihu.com/question/21455159/answer/59874307</code></pre><h3 id="10-阐述静态变量和实例变量的区别。"><a href="#10-阐述静态变量和实例变量的区别。" class="headerlink" title="10. 阐述静态变量和实例变量的区别。"></a>10. 阐述静态变量和实例变量的区别。</h3><blockquote><ol><li>静态变量（static 修饰的变量）属于类，被所有类的实例共享，没有实例时也可通过类直接访问</li><li>实例变量：必须通过实例来访问</li></ol></blockquote><h3 id="11-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#11-是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="11. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>11. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><blockquote><p>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化</p></blockquote><h3 id="12-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？"><a href="#12-抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？" class="headerlink" title="12. 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？"></a>12. 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？</h3><blockquote><ol><li>抽象方法不能是静态的：静态方法不能被子类重写，抽象方法必须被子类重写，冲突；</li><li>抽象方法不能是native的：本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的</li><li>抽象方法不能用sychronized：synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的</li></ol></blockquote><h3 id="13-Super与this表示什么"><a href="#13-Super与this表示什么" class="headerlink" title="13. Super与this表示什么"></a>13. Super与this表示什么</h3><blockquote><p>Super表示当前类的父类对象;This表示当前类的对象</p></blockquote><h3 id="14-hashcode-和equals-的关系"><a href="#14-hashcode-和equals-的关系" class="headerlink" title="14. hashcode()和equals()的关系"></a>14. hashcode()和equals()的关系</h3><blockquote><ol><li>equals 相等，hashcode一定相等</li><li>hashcode相等，equals不一定相等</li></ol></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="1-内部类的作用"><a href="#1-内部类的作用" class="headerlink" title="1. 内部类的作用"></a>1. <a href="https://blog.csdn.net/mid120/article/details/53644539" target="_blank" rel="noopener">内部类的作用</a></h3><blockquote><ol><li>内部类可以很好的实现隐藏</li><li>内部类拥有外围类的所有元素的访问权限</li><li>可以间接实现多重继承</li><li>可以避免修改接口而实现同一个类中两种同名方法的调用</li></ol></blockquote><h3 id="2-静态嵌套类-Static-Nested-Class-或者叫静态内部类-和内部类（Inner-Class）的不同"><a href="#2-静态嵌套类-Static-Nested-Class-或者叫静态内部类-和内部类（Inner-Class）的不同" class="headerlink" title="2. 静态嵌套类(Static Nested Class,或者叫静态内部类)和内部类（Inner Class）的不同"></a>2. 静态嵌套类(Static Nested Class,或者叫静态内部类)和内部类（Inner Class）的不同</h3><blockquote><ol><li>内部类持有外部类的引用（this），静态内部类不持有</li><li>因为持有外部类的引用，所以new时需要先有外部类的实例，再用外部类实例new内部类实例，举例：new Outer().new Inner();</li><li>扩展：在Android中，因为内部类持用外部类引用，所以容易造成内存泄漏，一般推荐使用静态内部类</li></ol></blockquote><h3 id="3-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#3-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="3. Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>3. Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h3><blockquote><p>可以继承其他类，也可以实现接口</p></blockquote><pre><code>解析：btn.setOnClickListener(new View.OnClickListener(){@Overridepublic void onClick(View view){}})这里new的就是一个匿名内部类，这个匿名内部类实现了View.OnClickListener接口。所以匿名内部类本身一定会继承或实现一个且仅一个类或者接口。复制代码</code></pre><h3 id="4-内部类-非静态内部类-可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#4-内部类-非静态内部类-可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="4. 内部类(非静态内部类)可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>4. 内部类(非静态内部类)可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h3><blockquote><ol><li>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</li><li>应用局部变量，局部变量前要加final修饰</li></ol></blockquote><h3 id="5-内部类访问局部变量的时候，为什么要加final"><a href="#5-内部类访问局部变量的时候，为什么要加final" class="headerlink" title="5. 内部类访问局部变量的时候，为什么要加final"></a>5. <a href="http://blog.csdn.net/z55887/article/details/49229491" target="_blank" rel="noopener">内部类访问局部变量的时候，为什么要加final</a></h3><blockquote><ol><li>内部类和局部变量生命周期不同（方法结束后局部变量的生命周期就结束了，而内部类只要有引用就不结束，内部类的生命周期&gt;=局部变量）</li><li>Java为了解决这一问题，会在编译时在内部类的构造方法里边，将局部变量作为参数传入内部类</li><li>这就造成了局部变量如果改变，内部类不知情的场景，所以要加final，保证引用不可改变</li></ol></blockquote><blockquote><p>扩展：在java8中，可以不使用final关键字，但是如果我们改变局部变量的引用，编译会发生错误，从而保证了局部变量的引用不变。</p></blockquote><h3 id="6-为什么内部类会持有外部类的引用？持有的引用是this？还是其它？"><a href="#6-为什么内部类会持有外部类的引用？持有的引用是this？还是其它？" class="headerlink" title="6. 为什么内部类会持有外部类的引用？持有的引用是this？还是其它？"></a>6. 为什么内部类会持有外部类的引用？持有的引用是this？还是其它？</h3><blockquote><p>内部类虽然和外部类写在同一个文件中， 但是编译完成后， 还是生成各自的class文件，内部类通过this访问外部类的成员。</p><ol><li>编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象</li><li>编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为内部类中添加的成员变量赋值；</li><li>在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。</li></ol></blockquote><h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><h3 id="1-java中的异常"><a href="#1-java中的异常" class="headerlink" title="1. java中的异常"></a>1. java中的异常</h3><blockquote><ol><li>基类是Throwable，Error和Exception继承自Throwable</li><li>Error通常是系统抛出来的，也可以catch到，但一般不可恢复，开发是也不做处理</li><li>Exception分为受检查异常和不受检查异常，受检查异常会在编译时强制要求我们try/catch</li></ol></blockquote><h3 id="2-throw-和-throws"><a href="#2-throw-和-throws" class="headerlink" title="2. throw 和 throws"></a>2. throw 和 throws</h3><blockquote><ol><li>throw:抛出异常</li><li>throws：在方法声明处使用，表示此方法可能抛出的异常，调用此方法处需要处理这些异常。</li></ol></blockquote><h3 id="3-Error和Exception有什么区别？"><a href="#3-Error和Exception有什么区别？" class="headerlink" title="3. Error和Exception有什么区别？"></a>3. Error和Exception有什么区别？</h3><blockquote><ol><li>Error是系统抛出的，不能在运行时捕获，比如内存溢出</li><li>Exception 是需要我们捕捉并处理的异常，如类型转换错误等，我们可以通过捕捉异常，使程序发生异常时仍可正常运行</li></ol></blockquote><h3 id="4-运行时异常与受检异常有何异同？"><a href="#4-运行时异常与受检异常有何异同？" class="headerlink" title="4. 运行时异常与受检异常有何异同？"></a>4. 运行时异常与受检异常有何异同？</h3><blockquote><ol><li>checked exception:这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行try/catch或者继续上抛</li><li>runtime exception:出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了</li></ol></blockquote><h3 id="5-列出一些你常见的运行时异常"><a href="#5-列出一些你常见的运行时异常" class="headerlink" title="5.  列出一些你常见的运行时异常"></a>5.  列出一些你常见的运行时异常</h3><blockquote><p>NullPointerException （空指针异常） ClassCastException （类转换异常） IndexOutOfBoundsException （下标越界异常） IllegalArgumentException （非法参数异常）</p></blockquote><h3 id="6-Exception继承相关考题"><a href="#6-Exception继承相关考题" class="headerlink" title="6. Exception继承相关考题"></a>6. Exception继承相关考题</h3><pre><code>题目1:类ExampleA继承Exception，类ExampleB继承ExampleA。有如下代码片断,请问执行此段代码的输出是什么？try {throw new ExampleB(&quot;b&quot;)} catch（ExampleA e）{System.out.println(&quot;ExampleA&quot;);} catch（Exception e）{System.out.println(&quot;Exception&quot;);}解析：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）题目2:class Annoyance extends Exception {}class Sneeze extends Annoyance {}class Human {public static void main(String[] args)throws Exception {try {try {throw new Sneeze();}catch ( Annoyance a ) {System.out.println(&quot;Caught Annoyance&quot;);throw a;}}catch ( Sneeze s ) {System.out.println(&quot;Caught Sneeze&quot;);return ;}finally {System.out.println(&quot;Hello World!&quot;);}}}解析：输出Caught AnnoyanceCaught SneezeHello World!</code></pre><h2 id="关键字和运算符"><a href="#关键字和运算符" class="headerlink" title="关键字和运算符"></a>关键字和运算符</h2><h3 id="1-amp-和-amp-amp-的区别；-和-的区别？"><a href="#1-amp-和-amp-amp-的区别；-和-的区别？" class="headerlink" title="1. &amp;和&amp;&amp;的区别；|和||的区别？"></a>1. &amp;和&amp;&amp;的区别；|和||的区别？</h3><blockquote><ol><li>&amp;有两种用法：(1)按位与；(2)逻辑与，我们这里说的是逻辑与。</li><li>与运算要求左右两端的布尔值都是true整个表达式的值才是true</li><li>&amp;&amp;运算符是短路逻辑与运算，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算</li><li>&amp;左右两边的表达式都会计算，我们常用&amp;&amp;，比如if(username != null &amp;&amp;!username.equals(“hahaha”)){}</li></ol></blockquote><h3 id="2-transient关键字"><a href="#2-transient关键字" class="headerlink" title="2, transient关键字"></a>2, transient关键字</h3><blockquote><p>如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程</p></blockquote><h3 id="3-修饰符的区别"><a href="#3-修饰符的区别" class="headerlink" title="3. 修饰符的区别"></a>3. 修饰符的区别</h3><p>修饰符一共有四个：private、protected、public和default（也有人管默认叫friendly）</p><blockquote><ol><li>private：私有的，除自己外任何类不能使用</li><li>protected：同包可以使用，其他包子类可以使用</li><li>public：任何类可以使用</li><li>default：同包可以使用，其他包不能使用</li></ol></blockquote><table><thead><tr><th>修饰符</th><th align="center">当前类</th><th align="center">同 包</th><th align="center">子 类</th><th align="right">其他包</th></tr></thead><tbody><tr><td>public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="right">√</td></tr><tr><td>protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="right">×</td></tr><tr><td>default</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="right">×</td></tr><tr><td>private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="right">×</td></tr></tbody></table><h3 id="4-Java有没有goto？"><a href="#4-Java有没有goto？" class="headerlink" title="4. Java有没有goto？"></a>4. Java有没有goto？</h3><blockquote><p>goto 和 const 是Java中的保留字，在目前版本的Java中没有使用。</p></blockquote><h3 id="5-在Java中，如何跳出当前的多重嵌套循环"><a href="#5-在Java中，如何跳出当前的多重嵌套循环" class="headerlink" title="5. 在Java中，如何跳出当前的多重嵌套循环"></a>5. 在Java中，如何跳出当前的多重嵌套循环</h3><blockquote><p>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环 (应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅)。</p></blockquote><h3 id="6-switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><a href="#6-switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？" class="headerlink" title="6. switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？"></a>6. switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</h3><blockquote><ol><li>在Java 5以前，switch(expr)中，expr只能是byte、short、char、int</li><li>Java 5开始，Java中引入了枚举类型，expr也可以是enum类型</li><li>从Java 7开始，expr还可以是字符串（String）</li><li>long类型不支持</li></ol></blockquote><h3 id="7-static"><a href="#7-static" class="headerlink" title="7. static"></a>7. static</h3><blockquote><ol><li>可以修饰内部类（静态内部类）</li><li>可以修饰成员变量，该变量属于类，被所有实例共享</li><li>可以修饰方法，该方法属于类，被所有实例共享</li><li>可以修饰代码块（静态代码块），该代码块在第一次被加载时被调用</li></ol></blockquote><h3 id="8-Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"><a href="#8-Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？" class="headerlink" title="8. Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？"></a>8. Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h3><blockquote><ol><li>Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。</li><li>Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；t</li><li>try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。</li></ol></blockquote><h3 id="9-阐述final、finally、finalize的区别。"><a href="#9-阐述final、finally、finalize的区别。" class="headerlink" title="9. 阐述final、finally、finalize的区别。"></a>9. 阐述final、finally、finalize的区别。</h3><blockquote><p>这是三个不同的概念，只是因为长得较像而被出成了一道题</p></blockquote><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final是一个修饰符，用来修饰类，变量，方法</p><blockquote><ol><li>final修饰的类不能被继承</li><li>final修饰的方法不能被重写</li><li>final修饰的成员变量是不可变的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是对象当中的内容是允许改变的</li></ol></blockquote><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><blockquote><p>finally与try，catch一起搭配使用，不论是否catch到异常，finally中的内容都会执行</p></blockquote><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><blockquote><p>finalize是Object类中的方法，垃圾回收器在垃圾回收时会调用该方法，我们可以在子类中重写该方法来做一些清理工作</p></blockquote><h3 id="10-finally-语句一定会执行吗"><a href="#10-finally-语句一定会执行吗" class="headerlink" title="10. finally 语句一定会执行吗"></a>10. finally 语句一定会执行吗</h3><p>在极特殊的情况下可能不执行</p><blockquote><ol><li>调用了System.exit()方法</li><li>JVM崩溃了</li></ol></blockquote><h2 id="基本类型和常用类"><a href="#基本类型和常用类" class="headerlink" title="基本类型和常用类"></a>基本类型和常用类</h2><h3 id="0-int和Integer有什么区别？"><a href="#0-int和Integer有什么区别？" class="headerlink" title="0. int和Integer有什么区别？"></a>0. int和Integer有什么区别？</h3><blockquote><ol><li>int是基本类型，Integer是int的包装类型</li><li>包装类型可以有一些自己的方法，引入包装类型可以使java更好的面向对象</li><li>每个基本类型都有其包装类：</li></ol><ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul></blockquote><pre><code>扩展1：java5中引入了自动拆装箱功能，例如在比较时可以自动拆装箱class AutoUnboxingTest {    public static void main(String[] args) {        Integer a = new Integer(3);        Integer b = 3;                  // 将3自动装箱成Integer类型        int c = 3;        System.out.println(a == b);     // false 两个引用没有引用同一对象        System.out.println(a == c);     // true a自动拆箱成int类型再和c比较    }}复制代码扩展2：一道和装箱有关的面试题public class Test03 {    public static void main(String[] args) {        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;        System.out.println(f1 == f2); //true        System.out.println(f3 == f4); //false    }}分析：自动装箱时，使用的时Integer的valueof方法，当int在-128到127之间时，并不会new一个新的对象，而是直接使用常量池中的Integer具体分析： public static Integer valueOf(int i) {        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)            return IntegerCache.cache[i + (-IntegerCache.low)];        return new Integer(i);    }IntegerCache是Integer的内部类，其代码如下所示：/**     * Cache to support the object identity semantics of autoboxing for values between     * -128 and 127 (inclusive) as required by JLS.     *     * The cache is initialized on first usage.  The size of the cache     * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.     * During VM initialization, java.lang.Integer.IntegerCache.high property     * may be set and saved in the private system properties in the     * sun.misc.VM class.     */    private static class IntegerCache {        static final int low = -128;        static final int high;        static final Integer cache[];        static {            // high value may be configured by property            int h = 127;            String integerCacheHighPropValue =                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);            if (integerCacheHighPropValue != null) {                try {                    int i = parseInt(integerCacheHighPropValue);                    i = Math.max(i, 127);                    // Maximum array size is Integer.MAX_VALUE                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);                } catch( NumberFormatException nfe) {                    // If the property cannot be parsed into an int, ignore it.                }            }            high = h;            cache = new Integer[(high - low) + 1];            int j = low;            for(int k = 0; k &lt; cache.length; k++)                cache[k] = new Integer(j++);            // range [-128, 127] must be interned (JLS7 5.1.7)            assert IntegerCache.high &gt;= 127;        }        private IntegerCache() {}    }    简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，    所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。复制代码</code></pre><h3 id="1-float-f-3-4-是否正确？"><a href="#1-float-f-3-4-是否正确？" class="headerlink" title="1. float f=3.4;是否正确？"></a>1. float f=3.4;是否正确？</h3><blockquote><p>答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</p></blockquote><h3 id="2-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#2-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="2. short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>2. short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h3><blockquote><ol><li>对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。</li><li>short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</li></ol></blockquote><h3 id="3-Java中char-型变量中能不能存贮一个中文汉字，为什么"><a href="#3-Java中char-型变量中能不能存贮一个中文汉字，为什么" class="headerlink" title="3. Java中char 型变量中能不能存贮一个中文汉字，为什么?"></a>3. Java中char 型变量中能不能存贮一个中文汉字，为什么?</h3><blockquote><p>Java中 char型变量用来存储Unicode编码的字符，unicode编码字符集中包含了汉字，所以char类型可以储存汉字 char类型占两个字节</p></blockquote><h3 id="4-数组有没有length-方法？String有没有length-方法？"><a href="#4-数组有没有length-方法？String有没有length-方法？" class="headerlink" title="4. 数组有没有length()方法？String有没有length()方法？"></a>4. 数组有没有length()方法？String有没有length()方法？</h3><blockquote><p>数组有length属性，String有length()方法</p></blockquote><h3 id="5-String是基本数据类型嘛"><a href="#5-String是基本数据类型嘛" class="headerlink" title="5. String是基本数据类型嘛"></a>5. String是基本数据类型嘛</h3><blockquote><ol><li>不是。</li><li>java中8个基本类型为：byte、short、char、int、float、long、double、boolean。</li><li>java中除基本类型外，都是引用类型（枚举是java5以后引入的特殊引用类型）</li><li>String类型比较特殊，不可变。但它不是基本类型</li></ol></blockquote><h3 id="6-是否可以继承String类"><a href="#6-是否可以继承String类" class="headerlink" title="6. 是否可以继承String类"></a>6. 是否可以继承String类</h3><blockquote><p>String 类是final的，不能被继承</p></blockquote><h3 id="7-String和StringBuilder、StringBuffer的区别"><a href="#7-String和StringBuilder、StringBuffer的区别" class="headerlink" title="7. String和StringBuilder、StringBuffer的区别"></a>7. String和StringBuilder、StringBuffer的区别</h3><blockquote><p>String 是只读字符串，StringBuilder和StringBuffer可以改变，StringBuilder效率高，线程不安全，StringBuffer线程安全。 在拼接String时，使用+编译器会帮我们进行优化，使用StringBuilder进行拼接，这时+和StringBuilder没有多大区别。但当循环中使用+时，我们应该显示的使用StringBuilder，以防止多次调用new StringBuilder，造成不必要的性能浪费。</p></blockquote><pre><code>循环中使用+举例：String str = &quot;hello,world!&quot;;        String result = &quot;&quot;;        for (int i = 0; i &lt; loopCount; i++) {            result += str;        }这个时候编译器会优化成String str = &quot;hello,world!&quot;;        String result = &quot;&quot;;        for (int i = 0; i &lt; loopCount; i++) {            result = new StringBuilder(result).append(str).toString();        }多次new StringBuilder造成了性能浪费。复制代码扩展例题class StringEqualTest {    public static void main(String[] args) {        String s1 = &quot;Programming&quot;;        String s2 = new String(&quot;Programming&quot;);        String s3 = &quot;Program&quot;;        String s4 = &quot;ming&quot;;        String s5 = &quot;Program&quot; + &quot;ming&quot;;        String s6 = s3 + s4;        System.out.println(s1 == s2); // false        System.out.println(s1 == s5); //true        System.out.println(s1 == s6); //false        System.out.println(s1 == s6.intern()); //true        System.out.println(s2 == s2.intern()); //false    }}解析：1. String是引用类型，这里 == 比较的是引用是否相同，即是否指向相同的地址     2. 在new String对象时，会产生一个新的对象，并不会使用常量池中的字符串     3. intern会在常量池中寻找该字符串（如果没有责新建），并返回他的地址复制代码</code></pre><h3 id="8-String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#8-String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="8. String s = new String(“xyz”);创建了几个字符串对象？"></a>8. String s = new String(“xyz”);创建了几个字符串对象？</h3><blockquote><p>两个对象，一个是静态区的”xyz”;一个是用new创建在堆上的对象。</p></blockquote><h3 id="9-String-和基本数据类型之间的转换"><a href="#9-String-和基本数据类型之间的转换" class="headerlink" title="9. String 和基本数据类型之间的转换"></a>9. String 和基本数据类型之间的转换</h3><blockquote><ol><li>String 转基本数据类型：调用基本数据类型对应包装类的parseXXX(String)或valueOf(String)方法</li><li>基本数据类型转String：基本数据类型+“”；String.valueof(12)</li></ol></blockquote><h3 id="10-实现字符串的反转"><a href="#10-实现字符串的反转" class="headerlink" title="10. 实现字符串的反转"></a>10. 实现字符串的反转</h3><blockquote><ol><li>方法有很多，可以用StringBuffer/StringBuilder的reverse方法，这里reverse是通过位移实现的</li><li>再举例一种递归方法：</li></ol></blockquote><pre><code>public String reverse(String originString){if(originString == null || originString.length &lt;= 1)return originString;return reverse(originString.subString(1)) + originString.charAt(0);}复制代码</code></pre><h3 id="11-String-为什么要设计成不可变的"><a href="#11-String-为什么要设计成不可变的" class="headerlink" title="11. String 为什么要设计成不可变的"></a>11. <a href="https://juejin.im/post/5aa1ee0c51882555677e2109" target="_blank" rel="noopener">String 为什么要设计成不可变的</a></h3><h4 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1. 安全性"></a>1. 安全性</h4><blockquote><ol><li>线程安全，不可变天生线程安全</li><li>String常被用作HashMap的key，如果可变会引有安全问题，如两个key相同</li><li>String常被用作数据库或接口的参数，可变的话也会有安全问题</li></ol></blockquote><h4 id="2-效率"><a href="#2-效率" class="headerlink" title="2. 效率"></a>2. 效率</h4><blockquote><ol><li>通过字符串池可以节省很多空间</li><li>每个String对应一个hashcode，再次使用的话不用重新计算</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rsync 使用</title>
      <link href="/2020/03/17/rsync/"/>
      <url>/2020/03/17/rsync/</url>
      
        <content type="html"><![CDATA[<h1 id="rsync-使用"><a href="#rsync-使用" class="headerlink" title="rsync 使用"></a>rsync 使用</h1><ul><li>h： human-readable, 输出友好</li><li>a： 合并模式；等于-rlptgoD（不含 -H -A -X）。</li><li>b： 制作备份。</li><li>C： 使用与CVS相同的方式来忽略文件。</li><li>u： 跳过比较新的文件。</li><li>v： 处理过程中，显示较多的信息。</li><li>z： 在传输过程中压缩文件。</li><li>–exclude： 排除通配模式匹配到的文件及文件夹。</li><li>a：合并了多个选项，其中每一项的含义如下：<ul><li>r： 递归的方式拷贝文件（recursive）。</li><li>l： 拷贝符号链接为符号链接（symlinks）。</li><li>p： 保留文件的权限信息（permissions）。</li><li>t： 保留文件的修改时间（times）。</li><li>g： 保留用户组信息（group）。</li><li>o： 保留所有者信息（owner）。</li><li>D： 等同于（–devices –specials）再次展开含义如下：<ul><li>–devices： 允许rsync传输字符设备和块设备</li><li>–specials： 允许rsync传输sockets文件和管道（fifos）文件。</li></ul></li></ul></li></ul><h4 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h4><pre class=" language-shell"><code class="language-shell">rsync -abCuvz /home/data/ /your/backup/</code></pre><p>会将<code>data</code>文件夹 备份到<code>/your/backup/</code>下</p><h4 id="增量备份并删除额外的文件"><a href="#增量备份并删除额外的文件" class="headerlink" title="增量备份并删除额外的文件"></a>增量备份并删除额外的文件</h4><pre class=" language-shell"><code class="language-shell">rsync -abCuvz /home/data/ /your/backup/</code></pre><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><pre class=" language-shell"><code class="language-shell">rsync -abuvz --exclude '*~' /your/backup/data/ /home/data/</code></pre><h4 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h4><p>在服务器上，通常需要备份多个目录，如备份/home 、/etc、/opt目录， 则可以用以下的参数：</p><pre class=" language-shell"><code class="language-shell">rsync -av root@serverhost:/home/ root@serverhost:/etc/ root@serverhost:/opt/ /local/backup/media/</code></pre><p>也可以省略后面的主机：</p><pre class=" language-shell"><code class="language-shell">rsync -av root@serverhost:/home/ :/etc/ :/opt/ /local/backup/media/</code></pre><p><a href="https://www.cnblogs.com/kevingrace/p/6601088.html" target="_blank" rel="noopener">linux下rsync和tar增量备份梳理</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rsync </tag>
            
            <tag> 备份 </tag>
            
            <tag> macOS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Custom Build Bilibili ijkplayer</title>
      <link href="/2020/03/05/ijkplayer-build/"/>
      <url>/2020/03/05/ijkplayer-build/</url>
      
        <content type="html"><![CDATA[<h1 id="Build-Bilibili-ijkplayer"><a href="#Build-Bilibili-ijkplayer" class="headerlink" title="Build Bilibili ijkplayer"></a>Build Bilibili ijkplayer</h1><h3 id="MacOS-环境"><a href="#MacOS-环境" class="headerlink" title="MacOS 环境"></a>MacOS 环境</h3><p>Homebrew<br>git、yasm</p><h4 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h4><p>必需 Android NDK 10-14</p><p><a href="https://developer.android.google.cn/ndk/downloads/older_releases.html" target="_blank" rel="noopener">https://developer.android.google.cn/ndk/downloads/older_releases.html</a></p><h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><pre><code>export ANDROID_NDK=~/workspace/android/ndk-r10eexport PATH=$PATH:$ANDROID_NDK</code></pre><h4 id="配置编解码器格式支持"><a href="#配置编解码器格式支持" class="headerlink" title="配置编解码器格式支持"></a>配置编解码器格式支持</h4><p>默认为最少支持，如果足够你使用，可以跳过这一步，否则可以改为以下配置:</p><ul><li>module-default.sh 更多的编解码器/格式</li><li>module-lite-hevc.sh 较少的编解码器/格式(包括 hevc)</li><li>module-lite.sh 较少的编解码器/格式(默认情况)</li></ul><pre><code>git clone https://github.com/bilibili/ijkplayer.git// 这步会下载 FFmpeg 源码，并自动执行 init-config.sh 和 ./init-android-libyuv.sh./init-android.sh// 如果需要启用 ssl、https 支持，执行这步./init-android-openssl.sh// 其他文件有待探索// ./init-android-j4a.sh// ./init-android-prof.sh// ./init-android-libsoxr.sh// ./init-android-exo.sh//build extracd android/contrib./compile-ffmpeg.sh clean./compile-ffmpeg.sh allcd .../compile-ijk.sh all</code></pre><h4 id="NDK-1"><a href="#NDK-1" class="headerlink" title="NDK"></a>NDK</h4><p>注意申明<code>ANDROID_NDK</code>为指定版本的</p><pre><code># export ANDROID_SDK=&lt;your sdk path&gt;# export ANDROID_NDK=&lt;your ndk path&gt;</code></pre><h4 id="0-8-8-Build"><a href="#0-8-8-Build" class="headerlink" title="0.8.8 Build"></a>0.8.8 Build</h4><p><code>module.sh</code> add this </p><pre><code>export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-linux-perf&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-bzlib&quot;</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/11493731ea2c" target="_blank" rel="noopener">https://www.jianshu.com/p/11493731ea2c</a></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><pre><code>// 添加格式、rtsp(tcp)支持export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=mpeg4&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=mp2*&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=ac3&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-decoder=mjpeg&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-demuxer=rtsp&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-demuxer=mjpeg&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-protocol=rtp&quot;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-protocol=tcp&quot;</code></pre><p>注释掉</p><pre><code>export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --disable-protocol=rtp&quot;</code></pre><h3 id="Gradlew"><a href="#Gradlew" class="headerlink" title="Gradlew"></a>Gradlew</h3><pre><code>#强制清除 gradle 依赖缓存./gradlew build --refresh-dependencies  </code></pre><h3 id="问题集合"><a href="#问题集合" class="headerlink" title="问题集合"></a>问题集合</h3><p>1、IJKPlayer 不像系统播放器会给你旋转视频角度，所以你需要通过<code>onInfo</code>的<code>what == IMediaPlayer.MEDIA_INFO_VIDEO_ROTATION_CHANGED</code>去获取角度，自己旋转画面；或者开启硬解硬解码，不过硬解码容易造成黑屏无声</p><pre><code>mediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec&quot;, 1);mediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec-auto-rotate&quot;, 1);mediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec-handle-resolution-change&quot;, 1);</code></pre><p>2、 IJKPlayer 出现黑色有声音没图像，看看你的视频编码是不是H264，pixel format是否存在，音频编码是不是AAC？默认IJKPlayer是不支持3pg（支持它干啥(・-・)？），不支持mepg（比如这个库RecordVideoDemo ）,不支持AMR。所以如果你真的想要支持，那么参考这个#1961，打开mpeg支持，重新编ffmpeg，然后通过硬解码播放mpeg；或者通过系统的录制VideoRecord；或者选另外的JAVACV录制封装FFmpegRecorder。</p><pre><code>ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec&quot;, 1);ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec_mpeg4&quot;, 1);</code></pre><p>3、 **快进和慢放接口，已经支持全版本，如果遇到声调问题，可以设置：</p><pre><code>ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;soundtouch&quot;, 1);</code></pre><p>4、暂停的时候，退到后台再回到前台，画面黑了？</p><p>1、<br>这时候个人处理方式是，可以在暂停的时候，通过TextureView.getBitmap(point.x, point.y);获取到暂停的画面，用ImageView显示它，在onSurfaceTextureUpdated的时候隐藏ImageView，来实现画面的衔接。</p><p>2、暂停时绘制静态画面多TextureView的Surface上，详细参考GSYVideoPlayer。</p><p>5、一些视频返回码</p><pre><code>int MEDIA_INFO_VIDEO_RENDERING_START = 3;//视频准备渲染int MEDIA_INFO_BUFFERING_START = 701;//开始缓冲int MEDIA_INFO_BUFFERING_END = 702;//缓冲结束int MEDIA_INFO_VIDEO_ROTATION_CHANGED = 10001;//视频选择信息int MEDIA_ERROR_SERVER_DIED = 100;//视频中断，一般是视频源异常或者不支持的视频类型。int MEDIA_ERROR_IJK_PLAYER = -10000,//一般是视频源有问题或者数据格式不支持，比如音频不是AAC之类的int MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK = 200;//数据错误没有有效的回收</code></pre><p>6、某些视频在SeekTo的时候，会跳回到拖动前的位置，这是因为视频的关键帧的问题，通俗一点就是FFMPEG不兼容，视频压缩过于厉害，seek只支持关键帧，出现这个情况就是原始的视频文件中i 帧比较少，可开启以下来解决：</p><pre><code>setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;enable-accurate-seek&quot;, 1);</code></pre><p>7、下载速度可以通过IjkMediaPlayer的getTcpSpeed获取。</p><p>8、高分辨率开启硬解码，不支持的话会自动切换到软解，就算开启mediacodec，如果设备不支持，显示的解码器也是avcodec软解。</p><p>9、ijkMediaPlayer.setOption可配置的对应头文件参考：ff_ffplay_options。</p><p>10、缓冲进度条不到100，官方表示我就不保证都100，所以一般我都是：</p><pre><code>//95这个数值可能不准确，有些时候可能还需要低一些if (secProgress &gt; 95) secProgress = 100;</code></pre><p>11、上面1、2、6的问题，在IJK封装的EXOPlayer和MediaPlayer都不会有问题，兼容上确实强过IJKPlayer，但是它们在细节上，却没有IJK处理的好，如EXOPlayer：退到后再回到前台、切换渲染控件的黑屏一段时间问题，除了用seekto之外目前没发现其他办法，这样的体验让我最后还是选择IJKPlayer。</p><p>12、设置cookie 可以通过ijkPlayer的public void setDataSource(String path, Map&lt;String, String&gt; headers) 的header实现设置，参考ijkPlayer的issues-1150，headers也是在内部被转化为何issuses一样的setOption方法</p><p>13、多个分片播放的功能，请查阅:</p><p><a href="https://github.com/CarGuo/GSYVideoPlayer/issues/64" target="_blank" rel="noopener">issues64-一个视频，多个视频片段问题</a><br><a href="https://github.com/Bilibili/ijkplayer/issues/490" target="_blank" rel="noopener">issues490分段视频</a><br><a href="https://www.jianshu.com/p/ea794a357b48" target="_blank" rel="noopener">ijkplayer-ffmpeg之concat</a></p><p>14、硬解码黑屏相关issuse以及建议<br><a href="https://github.com/Bilibili/ijkplayer/issues/1324" target="_blank" rel="noopener">android用硬解码播放器切后台恢复问题</a></p><p>14、硬解码黑屏相关issuse以及建议</p><p><a href="https://github.com/Bilibili/ijkplayer/issues/1324" target="_blank" rel="noopener">bilibili-issuse-1324</a></p><p>15、出现声音画面不同步</p><p>1、关了硬解码。</p><p>2、参考如下：</p><p><a href="http://www.jianshu.com/p/a5cf04181f3d" target="_blank" rel="noopener">http://www.jianshu.com/p/a5cf04181f3d</a><br>设置视频的倍速：<br>[options setPlayerOptionIntValue:10 forKey:@”framedrop”];<br>mediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, “framedrop”, 60);</p><p>16、rtsp播放失败问题</p><p><a href="https://github.com/CarGuo/GSYVideoPlayer/issues/232" target="_blank" rel="noopener">https://github.com/CarGuo/GSYVideoPlayer/issues/232</a></p><p><a href="https://github.com/CarGuo/GSYVideoPlayer/issues/207" target="_blank" rel="noopener">https://github.com/CarGuo/GSYVideoPlayer/issues/207</a></p><p>17、m3u8拖动seek之后，加载很长时间</p><p><a href="https://github.com/Bilibili/ijkplayer/issues/2874" target="_blank" rel="noopener">https://github.com/Bilibili/ijkplayer/issues/2874</a></p><p><a href="https://github.com/CarGuo/GSYVideoPlayer/issues/252" target="_blank" rel="noopener">https://github.com/CarGuo/GSYVideoPlayer/issues/252</a></p><p>18、m3u8本地播放问题</p><pre><code>ijkplayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;protocol_whitelist&quot;, &quot;crypto,file,http,https,tcp,tls,udp&quot;); </code></pre><p>19、断网自动重新连接<br>url前接上ijkhttphook:，如</p><p>String url = “ijkhttphook:<a href="http://baobab.wdjcdn.com/14564977406580.mp4&quot;" target="_blank" rel="noopener">http://baobab.wdjcdn.com/14564977406580.mp4&quot;</a>;<br>然后设置</p><pre class=" language-((IjkMediaPlayer)mediaPlayer).setOnNativeInvokeListener(new"><code class="language-((IjkMediaPlayer)mediaPlayer).setOnNativeInvokeListener(new">            @Override            public boolean onNativeInvoke(int i, Bundle bundle) {                return true;            }        })</code></pre><p>20、url切换400（http与https域名共用）</p><pre><code>ijkplayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1);</code></pre><p>21、Rtsp优化</p><pre><code>//硬解码：1、打开，0、关闭//mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;mediacodec&quot;, 1);//软解码：1、打开，0、关闭//mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;videotoolbox&quot;, 0);//rtsp设置 https://ffmpeg.org/ffmpeg-protocols.html#rtspmMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;rtsp_transport&quot;, &quot;tcp&quot;);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;rtsp_flags&quot;, &quot;prefer_tcp&quot;);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;allowed_media_types&quot;, &quot;video&quot;); //根据媒体类型来配置mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;timeout&quot;, 20000);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;buffer_size&quot;, 1316);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;infbuf&quot;, 1);  // 无限读mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;analyzemaxduration&quot;, 100L);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;probesize&quot;, 10240L);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;flush_packets&quot;, 1L);//  关闭播放器缓冲，这个必须关闭，否则会出现播放一段时间后，一直卡主，控制台打印 FFP_MSG_BUFFERING_START mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;packet-buffering&quot;, 0L);mMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, &quot;framedrop&quot;, 1L);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
            <tag> ijkplayer </tag>
            
            <tag> 编译 </tag>
            
            <tag> 多媒体 </tag>
            
            <tag> 视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 总结</title>
      <link href="/2020/02/26/git-summary/"/>
      <url>/2020/02/26/git-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="Git整理"><a href="#Git整理" class="headerlink" title="Git整理"></a>Git整理</h1><hr><h3 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git</h3><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>可以通过命令行<code>ssh-keygen</code>[Windows没有需要安装cmder类似软件支持]，或者<code>PuTTYgen</code>软件生成</p><pre><code>$ ssh-keygen -t rsa -C &quot;497633959@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/xuhaoyang/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/xuhaoyang/.ssh/id_rsa.Your public key has been saved in /Users/xuhaoyang/.ssh/id_rsa.pub.The key fingerprint is:SHA256:LGVPxsHQKFHyMjwcfVNRIZCNpro4ORUHTW6NYhbplSk 497633959@qq.comThe key&#39;s randomart image is:+---[RSA 2048]----+|      =B+Bo*+oo. ||     oE*B+O...   ||     .X=B+=.     ||     ooXo+       ||      .+S .      ||      o.         ||     + .         ||    = .          ||     o           |+----[SHA256]-----+</code></pre><p>默认生成密钥，公钥<code>id_rsa.pub</code>和私钥<code>id_rsa</code>，注意私钥必须自己保存不能外泄。</p><h4 id="初始化git-信息"><a href="#初始化git-信息" class="headerlink" title="初始化git 信息"></a>初始化git 信息</h4><pre><code>$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>版本库又名仓库，英文名<code>repository</code>。你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><pre><code>$ mkdir learngit$ cd learngit$ pwd/Users/michael/learngit</code></pre><p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。<br>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><pre><code>$ git initInitialized empty Git repository in /Users/michael/learngit/.git/</code></pre><p>一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><p>添加文件到Git仓库，分两步：</p><ul><li><p>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</p></li><li><p>第二步，使用命令<code>git commit</code>，完成。</p><h3 id="状态命令"><a href="#状态命令" class="headerlink" title="状态命令"></a>状态命令</h3></li><li><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p></li><li><p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式。</p></li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul><li>可以通过命令<code>git log</code>查看Git的历史记录。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数。</li><li>Git的<code>commit id</code>是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</li><li>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>3628164...882e1e0</code>，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</li><li>回退到上一版本的操作</li></ul><pre><code>$ git reset --hard HEAD^HEAD is now at ea34578 add distributed</code></pre><p>当回退完成之后，如果返回到回退之前的状态的话，可以通过<code>git reflog</code>命令查看git的记录，然后找到想要回退的<code>commit id</code>，就可以使用下面的命令返回到指定的commit。</p><pre><code>git reset --hard commit id</code></pre><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>在本地中，一个项目的目录就是一个工作区。<br>版本库，工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为<code>stage</code>（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向master的一个指针叫<code>HEAD</code>。</p><p><img src="media/14729548203031/1458722977422.png" alt="1458722977422"></p><p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p><ol><li>用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li><li>用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li></ol><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，<code>git commit</code>就是往<code>master</code>分支上提交更改。可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><h4 id="修改commit时间"><a href="#修改commit时间" class="headerlink" title="修改commit时间"></a>修改commit时间</h4><pre><code>git commit --amend --date=&quot;$(date -R)&quot;</code></pre><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>使用命令git checkout – file可以丢弃工作的的修改。这里存在两种情况：</p><ol><li>一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。</li></ol><p><code>git checkout -- file</code>命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令。</p><p>撤销修改有以下几个场景：</p><ol><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，可以使用版本回退。</li></ol><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>一般情况下，可以直接在文件管理器中把没用的文件删了，或者用rm命令删除。</p><pre class=" language-shell"><code class="language-shell">$ rm test.txt</code></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了。<br>现在有两种情况，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且<code>git commit</code>。<br>另一种情况是删错了，因为版本库里还有，所以可以通过命令<code>git checkout --file</code>来进行“一键还原”。</p><h3 id="撤出暂存区（或从暂存区删除）"><a href="#撤出暂存区（或从暂存区删除）" class="headerlink" title="撤出暂存区（或从暂存区删除）"></a>撤出暂存区（或从暂存区删除）</h3><p>使用 <code>git rm --cached &lt;file&gt;...</code> 撤出暂存区</p><h3 id="查看日志log"><a href="#查看日志log" class="headerlink" title="查看日志log"></a>查看日志log</h3><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p><code>-p</code> 选项展开显示每次提交的内容差异</p><p><code>--word-diff</code> 从而获取单词层面上的对比<br>git log –word-diff -U1<br><img src="media/14729548203031/15275755278746.jpg" alt="-w480"></p><p><code>--stat</code> 仅显示简要的增改行数统计<br><img src="media/14729548203031/15275754061918.jpg" alt="-w480"></p><p><code>--graph</code> 一些 ASCII 字符串表示的简单图形</p><pre><code> git log --oneline --stat --decorate --pretty=format:&quot;%h - %an, %ar : %s&quot;</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td></tr><tr><td>%an</td><td>作者（author）的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期（可以用 -date= 选项定制格式）</td></tr><tr><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%cn</td><td>提交者(committer)的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table><pre><code>git config --global alias.lm  &quot;log --no-merges --color --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;XHY&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;git config --global alias.lms  &quot;log --no-merges --color --stat --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;XHY&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;git config --global alias.ls &quot;log --no-merges --color --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;git config --global alias.lss &quot;log --no-merges --color --stat --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></pre><p><img src="media/14729548203031/15275769609397.jpg" alt="-w480"></p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>Git鼓励大量使用分支：<br>查看分支：<code>git branch</code><br>创建分支：<code>git branch &lt;name&gt;</code><br>切换分支：<code>git checkout &lt;name&gt;</code><br>创建+切换分支：<code>git checkout -b &lt;name&gt;</code><br>合并某分支到当前分支：<code>git merge &lt;name&gt;</code><br>删除分支：<code>git branch -d &lt;name&gt;</code><br>参考文章：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="noopener">创建和合并分支</a></p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>合并分支时出现冲突的情况：</p><pre><code>$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>通过使用命令<code>git status</code>可以查看冲突的文件。Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容。用<code>git log --graph</code>命令可以看到分支合并图。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，就是使用命令<code>git merge --no-ff -m &quot;message&quot; branch</code>，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用<code>Fast forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p><h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>开发一个新<code>feature</code>，最好新建一个分支；<br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="多人协助"><a href="#多人协助" class="headerlink" title="多人协助"></a>多人协助</h3><h5 id="查看远程库"><a href="#查看远程库" class="headerlink" title="查看远程库"></a>查看远程库</h5><p>要查看远程库的信息，用<code>git remote</code></p><pre><code>$ git remoteorigin</code></pre><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><pre><code>$ git remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)</code></pre><h5 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h5><p>远程仓库还为空时，或推送到新的一个远程仓库，与本地关联，使用<code>git remote add [origin名字] [git@github.com:michaelliao/learngit.git]</code></p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre><code>$ git push -u origin masterCounting objects: 19, done.Delta compression using up to 4 threads.Compressing objects: 100% (19/19), done.Writing objects: 100% (1a9/19), 13.73 KiB, done.Total 23 (delta 6), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git * [new branch]      master -&gt; masterBranch master set up to track remote branch master from origin.</code></pre><h5 id="取消远程与本地库关联"><a href="#取消远程与本地库关联" class="headerlink" title="取消远程与本地库关联"></a>取消远程与本地库关联</h5><pre><code>git remote remove [origin/名字]</code></pre><h5 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h5><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。<br>当你的小伙伴从远程库<code>clone</code>时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。<br>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><pre><code>$ git checkout -b dev origin/dev</code></pre><p>如果克隆指定分支</p><pre><code>$ git clone -b dev [地址]</code></pre><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程。<br>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送。这时就会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送。有时<code>git pull</code>也会失败，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和origin/dev的链接（建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>）：</p><pre><code>$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin.</code></pre><p>再pull：</p><pre><code>$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>这回git pull成功。</p><h3 id="推送本地分支到远程新分支"><a href="#推送本地分支到远程新分支" class="headerlink" title="推送本地分支到远程新分支"></a>推送本地分支到远程新分支</h3><p>命令<code>git push origin &lt;本地分支name&gt;:&lt;远程分支name&gt;</code>，将本地推送的远程新分支，注意推送成功后，再次用<code>git push</code>是无法直接推送成功，</p><pre><code>git push origin dev:dev</code></pre><h3 id="强制覆盖本地文件"><a href="#强制覆盖本地文件" class="headerlink" title="强制覆盖本地文件"></a>强制覆盖本地文件</h3><pre><code>git fetch --all  git reset --hard origin/master git pull</code></pre><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 <code>master</code> 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：<code>git push [远程名] :[分支名]</code>。如果想在服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><pre><code>$ git push origin :serverfixTo git@github.com:schacon/simplegit.git - [deleted]         serverfix</code></pre><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>Git的标签虽然是版本库的快照，但其实它就是指向某个<code>commit</code>的指针，<br>所以，创建和删除标签都是瞬间完成的。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ol><li>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个<code>commit id</code>；</li><li><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ol><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><ol><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ol><h3 id="优雅的删除子模块"><a href="#优雅的删除子模块" class="headerlink" title="优雅的删除子模块"></a>优雅的删除子模块</h3><pre class=" language-shell"><code class="language-shell"># 逆初始化模块，其中{MOD_NAME}为模块目录，执行后可发现模块目录被清空git submodule deinit {MOD_NAME} # 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）git rm --cached {MOD_NAME} # 提交更改到代码库，可观察到'.gitmodules'内容发生变更git commit -am "Remove a submodule." </code></pre><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>要push代码到git时，出现提示：</p><pre><code>error:failed to push some refs to ...Dealing with “non-fast-forward” errorsFrom time to time you may encounter this error while pushing:$ git push origin masterTo ../remote/! [rejected]        master -&gt; master (non-fast forward)error: failed to push some refs to &#39;../remote/&#39;To prevent you from losing history, non-fast-forward updates were rejectedMerge the remote changes before pushing again.  See the &#39;non-fast forward&#39;section of &#39;git push --help&#39; for details.</code></pre><p>问题<code>（Non-fast-forward）</code>的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。可以有两种解决方法:</p><ul><li>使用命令<code>git push -f</code>强推，利用强覆盖方式用你本地的代码替代git仓库内的内容。</li><li>先把<code>git</code>的东西<code>fetch</code>到你本地然后<code>merge</code>后再<code>push</code></li></ul><pre><code>$ git fetch$ git merge</code></pre><p>这2句命令等价于</p><pre><code>$ git pull</code></pre><p>可是，这时候又出现了如下的问题：<br>上面出现的 <code>[branch “master”]</code>是需要明确<code>(.git/config)</code>如下的内容</p><pre><code>[branch &quot;master&quot;]    remote = origin    merge = refs/heads/master</code></pre><p>这等于告诉<code>git</code> 2件事:<br>1，当你处于<code>master branch</code>, 默认的<code>remote</code>就是<code>origin</code>。<br>2，当你在<code>master branch</code>上使用<code>git pull</code>时，没有指定<code>remote</code>和<code>branch</code>，那么<code>git</code>就会采用默认的<code>remote</code>（也就是<code>origin</code>）来<code>merge</code>在master <code>branch</code>上所有的改变<br>如果不想或者不会编辑<code>config</code>文件的话，可以在<code>bush</code>上输入如下命令行：</p><pre><code>$ git config branch.master.remote origin$ git config branch.master.merge refs/heads/master</code></pre><p>之后再重新<code>git pull</code>。最后<code>git push</code>代码吧。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clash 使用教程</title>
      <link href="/2020/02/17/clash-tutorial/"/>
      <url>/2020/02/17/clash-tutorial/</url>
      
        <content type="html"><![CDATA[<p>Clash 是支持Windows、Linux、macOS、Android等多平台的代理软件。支持协议shadowsocks/V2ray。是主要以规则导向型软件。</p><h2 id="Clash-设置介绍"><a href="#Clash-设置介绍" class="headerlink" title="Clash 设置介绍"></a>Clash 设置介绍</h2><p>这里的设置，主要是指Clash软件当前Proxy运行模式。<br>有<code>Global-全局</code>、<code>Rule-规则</code>、<code>Direct-直连</code>。</p><p><code>Global</code> 指全部数据通过选择的节点进行网络访问<br><code>Rule</code> 请求根据根据配置决定是走翻墙还是不翻墙(往下会进行说明)<br><code>Direct</code> 请求不进行代理(翻墙)</p><p>Clash for Windows 相关设置如图<br><img src="clashl1.jpg" alt=""></p><p>Clash for Android 暂无此类设置</p><p>ClashX(Mac OS) 相关设置如图<br><img src="clashl2.jpg" alt=""></p><h3 id="Clash-代理组介绍"><a href="#Clash-代理组介绍" class="headerlink" title="Clash 代理组介绍"></a>Clash 代理组介绍</h3><p>这里以ClashX的图进行介绍，其他系统的Clash可以参考</p><p>默认情况下什么都不改动，是可以自动翻墙。<br>图中的分组，是来自DlerCloud。</p><p><img src="clashl3.jpg" alt=""></p><p><code>Auto - UrlTest</code> 自动根据网络延迟选择节点，会选择延迟最低的服务器。但延迟低不代表速度快。<br><code>Proxy</code> 代理组，主要的外国网站会走这个代理组，如图选择了<code>Auto - UrlTest</code>，则是根据<code>Auto - UrlTest</code>组自动选择节点进行翻墙。<br><code>Domestic</code> 代理组，主要国内重点网站/国内IP会走这个代理组，如图改代理组选择了<code>DIRECT</code>，则是直连<br><code>Others</code> 代理组，部分特殊外国网站走这个代理组。<br><code>Adblock</code> 代理组，部分广告网址 会走这个代理组，如图选择了<code>REJECT</code>(阻断)，匹配中的广告将无法显示。<br><code>Apple</code> 代理组，Apple 有关服务会走这个代理组。<br><code>AsinTV</code> 代理组，如 youku，爱奇艺，bilibil等中国大陆视频网站走这个代理组。<br><code>GlobalTV</code> 代理组，如Youtube等国外视频网站走这个代理组。<br><code>Telegram</code> 代理组，Telegram 聊天软件走这个代理组<br><code>Speedtest</code> 代理组，speedtest.net测速走这个代理组<br><code>Mircrosoft</code> 代理组，微软相关网络服务走这个代理组。</p><p>每个代理组中，所选择的节点，则为该代理组所匹配到的网站，会从哪个节点进行访问。</p><p>但有一些共有参数：</p><ul><li><code>DIRECT</code> 直连</li><li><code>REJECT</code> 阻断</li></ul><p>节点中如果包含<code>back</code>，则为外国用户访问国内服务使用。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClashX</title>
      <link href="/2020/02/17/clashx/"/>
      <url>/2020/02/17/clashx/</url>
      
        <content type="html"><![CDATA[<ul><li><p>系统要求: Mac OS 10.5 及以上</p><blockquote><p>ClashX 不兼容SSR 协议</p></blockquote><blockquote><p>首次使用 ClashX 时，macOS 会提醒你此应用来自未知开发者，请允许打开此应用。<br><br>ClashX 首次运行会提示是否安装帮助程序（Helper）。此帮助程序用于设置系统代理，否则每次你通过 ClashX 变更系统系统状态（打开或关闭）时都需要输入密码，请点击「Install」，之后 macOS 会提示输入用户密码。</p></blockquote><p><img src="clashx1.png" alt="clashx1"></p></li></ul><ol><li>从右上角的状态栏找到 ClashX 图标并进行鼠标右键</li><li>通过 配置 - 托管配置 - 管理 点击，等待窗口弹出</li></ol><p><img src="clashx2.jpg" alt="clashx2"></p><ol start="3"><li>点击 添加 ，等待窗口弹出</li><li><code>Url</code> 输入 对应的订阅地址，<code>Config Name</code> 可以随意填，点击确定。</li></ol><p><img src="clashx3.jpg" alt="clashx3"></p><ol start="5"><li>等待出现配置列表 如图</li></ol><p><img src="clashx4.jpg" alt="clashx4"></p><p>6.点击 [设置为系统代理] 即可<br><img src="clashx5.png" alt="clashx5"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人员记录</title>
      <link href="/2020/02/16/people-record/"/>
      <url>/2020/02/16/people-record/</url>
      
        <content type="html"><![CDATA[<h1 id="人员记录"><a href="#人员记录" class="headerlink" title="人员记录"></a>人员记录</h1><h2 id="一起用名单"><a href="#一起用名单" class="headerlink" title="一起用名单"></a>一起用名单</h2><ul><li>tiger <a href="mailto:okeydokeytiger@gmail.com">okeydokeytiger@gmail.com</a></li><li>tiger 朋友 <a href="mailto:1131998699@qq.com">1131998699@qq.com</a></li><li>cjy     <a href="mailto:eddycjy@gmail.com">eddycjy@gmail.com</a></li><li>cjy涛哥 <a href="mailto:cuojuexiaoyao@gmail.com">cuojuexiaoyao@gmail.com</a></li><li>欧惠玲 <a href="mailto:celineoubaby@gmail.com">celineoubaby@gmail.com</a></li><li>xielang <a href="mailto:beatdoudou123@gmail.com">beatdoudou123@gmail.com</a></li><li>xiaohang <a href="mailto:1347402353@qq.com">1347402353@qq.com</a></li><li>zhuyifeng <a href="mailto:zero0c@163.com">zero0c@163.com</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
